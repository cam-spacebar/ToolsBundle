<?php

namespace VisageFour\Bundle\ToolsBundle\Services;

use App\Entity\Person;
use App\Services\PasswordManager;
use App\Traits\FlashBagTrait;
use App\Twencha\Bundle\EventRegistrationBundle\Exceptions\ApiErrorCode;
use App\VisageFour\Bundle\ToolsBundle\Exceptions\AccountAlreadyVerified;
use App\VisageFour\Bundle\ToolsBundle\Exceptions\AccountNotVerifiedException;
use App\VisageFour\Bundle\ToolsBundle\Exceptions\PersonNotFound;
use Doctrine\ORM\EntityManager;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;
use Twencha\Bundle\EventRegistrationBundle\Repository\PersonRepository;
use Twencha\Bundle\EventRegistrationBundle\Services\PersonManager;
use VisageFour\Bundle\ToolsBundle\Exceptions\PasswordValidationException;
use VisageFour\Bundle\ToolsBundle\Exceptions\UserNotLoggedInException;
use VisageFour\Bundle\ToolsBundle\Interfaces\ApiErrorCodeInterface;
use VisageFour\Bundle\ToolsBundle\Traits\LoggerTrait;

class AppSecurity
{
    use LoggerTrait;
    use FlashBagTrait;

    /**
     * @var TokenStorageInterface
     */
    private $tokenStorageInterface;

    /**
     * @var ResponseAssembler
     */
    private $ra;

    /**
     * @var AuthenticationUtils
     */
    private $authenticationUtils;

    /**
     * @var PersonRepository
     */
    private $personRepo;

    /**
     * @var PersonManager
     */
    private $personMan;

    /**
     * @var EntityManager
     */
    private $em;

    /**
     * @var PasswordManager
     */
    private $passwordManager;

    /**
     * @var BaseFrontendUrl
     */
    private $baseFrontendUrl;

    public function __construct(
        TokenStorageInterface $tokenStorageInterface,  ResponseAssembler $ra, AuthenticationUtils $authenticationUtils,
        PersonManager $personMan, PersonRepository $personRepo, EntityManager $em, BaseFrontendUrl $baseFrontendUrl, PasswordManager $passwordManager
    ) {
        $this->tokenStorageInterface    = $tokenStorageInterface;
        $this->ra                       = $ra;
        $this->authenticationUtils      = $authenticationUtils;
        $this->personRepo               = $personRepo;
        $this->personMan                = $personMan;
        $this->em                       = $em;

        $this->passwordManager          = $passwordManager;
        $this->baseFrontendUrl          = $baseFrontendUrl;
    }

    /**
     * @param Request $request
     * @return JsonResponse
     * @throws \Exception
     *
     * Handle the final part of the login attempt (when it has failed): sending the response (to the client).
     */
    public function getLoginAttemptErrorResponse(Request $request): JsonResponse
    {
//        $this->logger->info('request', $request);
        $loggedInUser = $this->getLoggedInUser();

        // get the login error if there is one
        $authError = $this->authenticationUtils->getLastAuthenticationError(); /// this is generated by class: CustomUserMessageAuthenticationException (in the authenticator class)
        $errorMsg = (!empty($authError)) ? $authError->getMessageKey() : null;

        // old:
//        switch ($errorMsg) {
////            case 'Invalid credentials.':
////                $errorCode = ApiErrorCode::INVALID_CREDENTIALS;
////                break;
//            case ApiErrorCode::ACCOUNT_NOT_VERIFIED:
//                // the errorMsg should correspond to a ApiErrorCode, if not, throw an exception
//
//                public function checkCodeIsValid ($code)
//                break;
//            default:
//
//        }

        if (!ApiErrorCode::checkCodeIsValid($errorMsg)) {
            throw new \Exception('errorMsg: "'. $errorMsg .'" is not recognised and cannot be converted into an valid ApiErrorCode::constant');
        }
        $errorCode = $errorMsg;

        if (!empty($error)) {
            // if there was an authentication error, BUT the user is already logged in, change the error message.
            $errorCode = ($loggedInUser !== 'anon.') ? ApiErrorCode::ALREADY_LOGGED_IN : $errorCode;
//            $this->ra->addErrorMessage($msg);
        }

        // transcribe into a "normal"/standard error that assembleJson can understand.
        $e = new ApiErrorCode($errorCode);
        // get the last username entered by the user
        $data = ['lastEmail' => $this->authenticationUtils->getLastUsername()];
        return $this->ra->assembleJsonResponse($data, BaseFrontendUrl::NO_REDIRECTION, $e);
    }

    public function logoutUser (Request $request)
    {
        // clear the token, cancel session and redirect
        $this->tokenStorageInterface->setToken();

        $request->getSession()->invalidate();

        return $this->ra->assembleJsonResponse(null, BaseFrontendUrl::HOME);
    }

    /**
     * Returns a POST parameter or returns an error to the client (if the parameter value doesn't exist)
     */
    private function getPOSTParam (Request $request, string $paramName) {
        // this uses: symfony-bundles/json-request-bundle (for the nice shorthand ->get() command)
        $value = $request->get($paramName);

        if (empty($value)) {
            throw new ApiErrorCode(
                ApiErrorCode::INPUT_MISSING,
                'You must provide a "'. $paramName .'" field'
            );
        }

        return $value;
    }

    /**
     * verify the provided (account) verification token against a users account.
     * If successful, redirect them to the reset password page (with a reset token) - as they have not yet set a password.
     */
    public function verifyEmailAccountViaToken($email, $token)
    {
        try {
            // must be via GET (not POST) as the link is sent via email where POST is not possible.
//            $email = $this->getPOSTParam($request,'email');
//            $token = $this->getPOSTParam($request,'token');

            $person = $this->getPersonByEmailAddress($email);

            // Attempt to verify the token.
            try {
                $changePasswordToken = $this->verifyAccountAndGetChangePasswordToken($person, $token);
            } catch (AccountAlreadyVerified $e) {
                // transcribe the exception into an ApiErrorCode object.
                // continue to redirect the user if they haven't yet set their password'
                $redirect = null;
                if (!$person->hasPasswordBeenSet()) {
                    // redirect to reset password page.
                    $redirect = BaseFrontendUrl::CHANGE_PASSWORD;
                }
                throw new ApiErrorCode(ApiErrorCode::ACCOUNT_ALREADY_VERIFIED, null, $redirect);
            }

            // token was correct (and account is now verified) - so they must set a password:
            $redirect = BaseFrontendUrl::CHANGE_PASSWORD;
            // send password token for use when the front-end redirects to reset_password page
            // todo: security: is this vulnerable? (sending the token to the client? however, it's straight after verifying the email account.)
            $data = ['changePasswordToken' => $changePasswordToken];

            $this->em->flush();

            return $this->ra->assembleJsonResponse($data, $redirect);
        } catch (ApiErrorCodeInterface $e) {
            return $this->ra->assembleJsonResponse(null, $e->getRedirectionCode(), $e);
        }
    }

    /**
     * @param Person $person
     * @return bool
     * @throws ApiErrorCode
     *
     * check if the $person is verified, if not, provide a standard ApiErrorCode exception object.
     */
    private function checkIsAccountVerified(Person $person): bool
    {
        try {
            $person->isVerified(true);
        } catch (AccountNotVerifiedException $e) {
            // transcribe exception to ApiErrorCode object.

            throw new ApiErrorCode(ApiErrorCode::ACCOUNT_NOT_VERIFIED, $e->getPublicMsg());
        }

        return true;
    }

    private function getPersonByEmailAddress(string $email): Person
    {
        try {
            // attempt token/account verification
            $person = $this->personRepo->findOneByEmailCanonical($email);
        } catch (PersonNotFound $e) {
            // transcribe the error:
            throw new ApiErrorCode(ApiErrorCode::INVALID_EMAIL_ADDRESS, $e->getPublicMsg());
        }

        return $person;
    }

    public function handleChangePasswordRequest(Request $request)
    {
        try {
            $providedToken  = $this->getPOSTParam($request,'changePasswordToken');
            $email          = $this->getPOSTParam($request,'email');
            $newPassword    = $this->getPOSTParam($request,'newPassword');

            $person = $this->getPersonByEmailAddress($email);
            $this->attemptChangePassword($person, $newPassword, $providedToken);
            $this->checkIsAccountVerified($person);
        } catch (ApiErrorCodeInterface $e) {
            return $this->ra->assembleJsonResponse(null, $e->getRedirectionCode(), $e);
        }

        return $this->ra->assembleJsonResponse(
            null,
            BaseFrontendUrl::MAIN_LOGGED_IN_USER_MENU
        );

    }

    public function attemptChangePassword(Person $person, string $newPassword, string $changePasswordToken)
    {
        if (!$person->isChangePasswordTokenCorrect($changePasswordToken)) {
            throw new ApiErrorCode(ApiErrorCode::INVALID_EMAIL_ADDRESS);
        }

        // update the password
        try {
            $this->passwordManager->validatePasswordAndEncode($person, $newPassword);
        } catch (PasswordValidationException $e) {
            throw new ApiErrorCode(ApiErrorCode::INVALID_PASSWORD, $e->getPublicMsg() );
        }

        $this->em->persist($person);
        $this->em->flush();

        // todo: somehow close all logins with the old password?

        $this->addSuccessMsgToFlashBag('Your password has been updated successfully.');

        return true;
    }

    /**
     * @param string $email
     * @param string $token
     * @return bool
     * @throws \App\VisageFour\Bundle\ToolsBundle\Exceptions\PersonNotFound
     *
     * Return true if the verification token is correct (and not already verified)
     */
    private function attemptAccountVerification(Person $person, string $token): bool
    {
        $result = $person->checkVerificationToken($token);
        $this->em->persist($person);

        if ($result == false) {
            return false;
        }

        // verification token is valid
        $this->addSuccessMsgToFlashBag('This account has been verified successfully. Please now set your password.');

        return true;
    }

    public function verifyAccountAndGetChangePasswordToken(Person $person, string $token): string
    {
        $result = $this->attemptAccountVerification($person, $token);

        if (!$result) {
            throw new ApiErrorCode(ApiErrorCode::INVALID_ACCOUNT_VERIFICATION_TOKEN);
        }

        $token = $person->createChangePasswordToken();
        return $token;
    }

    public function getLoggedInUser ($throw = false) {
        $token = $this->tokenStorageInterface->getToken();
        if (empty($token)){
            return 'anon.';
        }

        if ($token->getUser() == 'anon.') {
            if ($throw) {
//                die('werwert');
                throw new UserNotLoggedInException();
            }
        };
        return $token->getUser();
    }

    /**
     * Redirect to the front-end login page if no user is logged in.
     */
    public function getLoggedInUserOrRedirectToLogin (): ?Person {
//        try {
            $person = $this->getLoggedInUser(true);

        
//        }
//        } catch (ApiErrorCode $e) {
////            work from here.
////            die ('usernot found!');
//        }

        if (empty($person)) {
//            throw new ApiErrorCode(
//                ApiErrorCode::LOGIN_REQU IRED,
//                null,
//                BaseFrontendUrl::LOGIN
//            );

//            throw new UserNotLoggedInException();
        }
        // todo: add the destination the user originally wanted to their session.

        return $person;
    }
}