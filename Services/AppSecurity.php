<?php

namespace VisageFour\Bundle\ToolsBundle\Services;

use App\Entity\Person;
use App\Services\EmailRegisterManager;
use App\Services\FrontendUrl;
use App\Traits\FlashBagTrait;
use App\Exceptions\ApiErrorCode;
use VisageFour\Bundle\ToolsBundle\Exceptions\AccountAlreadyVerified;
use App\Exceptions\PersonNotFound;
use Doctrine\ORM\EntityManager;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationUtils;
use Twencha\Bundle\EventRegistrationBundle\Repository\PersonRepository;
use Twencha\Bundle\EventRegistrationBundle\Services\PersonManager;
use VisageFour\Bundle\ToolsBundle\Exceptions\PasswordValidationException;
use App\Exceptions\UserNotLoggedInException;
use VisageFour\Bundle\ToolsBundle\Interfaces\ApiErrorCodeInterface;
use VisageFour\Bundle\ToolsBundle\Traits\LoggerTrait;

class AppSecurity
{
    use LoggerTrait;
    use FlashBagTrait;

    /**
     * @var TokenStorageInterface
     */
    private $tokenStorage;

    /**
     * @var ResponseAssembler
     */
    private $ra;

    /**
     * @var AuthenticationUtils
     */
    private $authenticationUtils;

    /**
     * @var PersonRepository
     */
    private $personRepo;

    /**
     * @var PersonManager
     */
    private $personMan;

    /**
     * @var EntityManager
     */
    private $em;

    /**
     * @var PasswordManager
     */
    private $passwordManager;

    /**
     * @var BaseFrontendUrl
     */
    private $baseFrontendUrl;

    /**
     * @var EmailRegisterManager
     */
    private $emailRegisterMan;

    /**
     * @var ApiErrorCode
     */
    private $apiErrorCode;

    public function __construct(
        TokenStorageInterface $tokenStorageInterface, ResponseAssembler $ra, AuthenticationUtils $authenticationUtils,
        PersonManager $personMan, PersonRepository $personRepo, EntityManager $em, FrontendUrl $frontendUrl, PasswordManager $passwordManager, EmailRegisterManager $emailRegisterManager
    ) {
        $this->tokenStorage    = $tokenStorageInterface;
        $this->ra                       = $ra;
        $this->authenticationUtils      = $authenticationUtils;
        $this->personRepo               = $personRepo;
        $this->personMan                = $personMan;
        $this->em                       = $em;

        $this->passwordManager          = $passwordManager;
        $this->baseFrontendUrl          = $frontendUrl;
        $this->emailRegisterMan         = $emailRegisterManager;
        $this->apiErrorCode             = new ApiErrorCode(ApiErrorCode::OK);
    }

    /**
     * @param Request $request
     * @return JsonResponse
     * @throws \Exception
     *
     * Handle the final part of the login attempt (when it has failed): sending the response (to the client).
     */
    public function getLoginAttemptErrorResponse(Request $request): JsonResponse
    {
//        $this->logger->info('request', $request);
        $loggedInUser = $this->getLoggedInUser();

        // get the login error if there is one
        $authError = $this->authenticationUtils->getLastAuthenticationError(); /// this is generated by class: CustomUserMessageAuthenticationException (in the authenticator class)
        $errorMsg = (!empty($authError)) ? $authError->getMessageKey() : null;

        switch ($errorMsg) {
            case 'Invalid credentials.':
                $errorCode = ApiErrorCode::INVALID_CREDENTIALS;
                break;
            default:
                $errorCode = $errorMsg;
                break;
//            case ApiErrorCode::ACCOUNT_NOT_VERIFIED:
//                // the errorMsg should correspond to a ApiErrorCode, if not, throw an exception
//
//                break;
        }

        if (!$this->apiErrorCode->checkConstantIsValid($errorCode)) {
            throw new \Exception('errorMsg: "'. $errorMsg .'" is not recognised and cannot be converted into an valid ApiErrorCode::constant');
        }

        if (!empty($errorCode)) {
            // if there was an authentication error, BUT the user is already logged in, change the error message.
            $errorCode = ($loggedInUser !== 'anon.') ? ApiErrorCode::ERROR_BUT_ALREADY_LOGGED_IN : $errorCode;
//            $this->ra->addErrorMessage($msg);
        }

        // transcribe into a "normal"/standard error that assembleJson can understand.
//        dd($errorCode);
        $e = new ApiErrorCode($errorCode);
        // get the last username entered by the user
        $data = ['lastEmail' => $this->authenticationUtils->getLastUsername()];
        return $this->ra->assembleJsonResponse($data, BaseFrontendUrl::NO_REDIRECTION, $e);
    }

    public function logoutUser (Request $request)
    {
        // clear the token, cancel session and redirect
        $this->tokenStorage->setToken(null);

        $session = $request->getSession();

//        $session->clear();
        $session->invalidate();
//        dd($session);

        return $this->ra->assembleJsonResponse(null, FrontendUrl::HOME);
    }

    /**
     * Returns a POST parameter or returns an error to the client (if the parameter value doesn't exist)
     */
    public function getPOSTParam (Request $request, string $paramName) {
        // this uses: symfony-bundles/json-request-bundle (for the nice shorthand ->get() command)
        $value = $request->get($paramName);

        if (empty($value)) {
            throw new ApiErrorCode(
                ApiErrorCode::INPUT_MISSING,
                'You must provide a "'. $paramName .'" field as an GET/POST'
            );
        }

        return $value;
    }

    /**
     * verify the provided (account) verification token against a users account.
     * If successful, redirect them to the reset password page (with a reset token) - as they have not yet set a password.
     */
    public function verifyEmailAccountViaToken($email, $token)
    {
        try {
            // must be via GET (not POST) as the link is sent via email where POST is not possible.
//            $email = $this->getPOSTParam($request,'email');
//            $token = $this->getPOSTParam($request,'token');

            $person = $this->getPersonByEmailAddress($email);

            // Attempt to verify the token.
            try {
                $changePasswordToken = $this->verifyAccountAndGetChangePasswordToken($person, $token);
            } catch (AccountAlreadyVerified $e) {
                // transcribe the exception into an ApiErrorCode object.
                // continue to redirect the user if they haven't yet set their password'
                $redirect = null;
                if (!$person->hasPasswordBeenSet()) {
                    // redirect to reset password page.
                    $redirect = BaseFrontendUrl::RESET_PASSWORD;
                }
                throw new ApiErrorCode(ApiErrorCode::ACCOUNT_ALREADY_VERIFIED, null, $redirect);
            }

            // token was correct (and account is now verified) - so they must set a password:
            $redirect = BaseFrontendUrl::RESET_PASSWORD;
            // send password token for use when the front-end redirects to reset_password page
            // todo: security: is this vulnerable? (sending the token to the client? however, it's straight after verifying the email account.)
            $redirectData = [
                'email'                 => $person->getEmail(),
                'reset_password_token'  => $changePasswordToken
            ];
//            dump('9fvuh', $redirect); // zzz

            $this->em->flush();
            $data = null;

            return $this->ra->assembleJsonResponse($data, $redirect, null, $redirectData);
        } catch (ApiErrorCodeInterface $e) {
            return $this->ra->assembleJsonResponse(null, $e->getRedirectionCode(), $e);
        }
    }

    private function getPersonByEmailAddress(string $email): Person
    {
        // tood: move this to personmanager?
        try {
            // attempt token/account verification
            $this->logger->info('looking for user with email: '. $email);
            $person = $this->personRepo->findOneByEmailCanonical($email);
        } catch (PersonNotFound $e) {
            // transcribe the error:
            throw new ApiErrorCode(ApiErrorCode::INVALID_EMAIL_ADDRESS, $e->getPublicMsg());
        }

        return $person;
    }

    /**
     * @param Request $request
     * @return JsonResponse
     * @throws \Exception
     *
     * 'reset password' is different from 'change password' in that it requires a token.
     * This is used for both: initial set of password (straight after account verification) and "forgot my password" resetting.
     */
    public function handleResetPasswordRequest(Request $request)
    {
        try {
            $providedToken  = $this->getPOSTParam($request,'changePasswordToken');
            $email          = $this->getPOSTParam($request,'email');
            $newPassword    = $this->getPOSTParam($request,'newPassword');

            $person = $this->getPersonByEmailAddress($email);

            $this->attemptChangePassword($person, $newPassword, $providedToken);
            $person->isVerified(true);
        } catch (ApiErrorCodeInterface $e) {
            return $this->ra->assembleJsonResponse(null, $e->getRedirectionCode(), $e);
        }

        return $this->ra->assembleJsonResponse(
            null,
            BaseFrontendUrl::MAIN_LOGGED_IN_USER_MENU
        );
    }

    /**
     * @param Request $request
     * @return JsonResponse
     * @throws \Exception
     *
     * Send a password reset token to the users email address.
     */
    public function processForgotMyPasswordRequest(string $email)
    {
        $person = $this->getPersonByEmailAddress($email);
        $token = $person->createChangePasswordToken();

        $this->emailRegisterMan->sendResetPasswordTokenEmail($person, $token);

        $this->ra->addSuccessMessage('We have sent you a password reset email to your email address. (please also check your spam folder).');

        return $this->ra->assembleJsonResponse(
            null,
            BaseFrontendUrl::LOGIN
        );
    }

    public function attemptChangePassword(Person $person, string $newPassword, string $changePasswordToken)
    {
        $this->logger->info('change password token comparison: '. $person->getChangePasswordToken() .' =? '. $changePasswordToken);
        if (!$person->isChangePasswordTokenCorrect($changePasswordToken)) {
            throw new ApiErrorCode(ApiErrorCode::CHANGE_PASSWORD_TOKEN_INVALID);
        }

        // update the password
        try {
            $this->passwordManager->validatePasswordAndEncode($person, $newPassword);
        } catch (PasswordValidationException $e) {
            throw new ApiErrorCode(ApiErrorCode::INVALID_NEW_PASSWORD, $e->getPublicMsg() );
        }

        $this->em->persist($person);
        $this->em->flush();

        // todo: somehow close all logins with the old password?

        $this->addSuccessMsgToFlashBag('Your password has been updated successfully.');

        return true;
    }

    /**
     * @param string $email
     * @param string $token
     * @return bool
     * @throws \App\Exceptions\PersonNotFound
     *
     * Return true if the verification token is correct (and not already verified)
     */
    private function attemptAccountVerification(Person $person, string $token): bool
    {
        $result = $person->checkVerificationToken($token);
        $this->em->persist($person);

        if ($result == false) {
            return false;
        }

        // verification token is valid
        $this->addSuccessMsgToFlashBag('This account has been verified successfully. Please now set your password.');

        return true;
    }

    public function verifyAccountAndGetChangePasswordToken(Person $person, string $token): string
    {
        $result = $this->attemptAccountVerification($person, $token);

        if (!$result) {
            throw new ApiErrorCode(ApiErrorCode::INVALID_ACCOUNT_VERIFICATION_TOKEN);
        }

        $token = $person->createChangePasswordToken();
        return $token;
    }

    public function getLoggedInUser ($throw = false) {
        $token = $this->tokenStorage->getToken();
        if (empty($token)){
            return 'anon.';
        }

        if ($token->getUser() == 'anon.') {
            if ($throw) {
//                die('werwert');
                throw new UserNotLoggedInException();
            }
        };
        return $token->getUser();
    }

    /**
     * Redirect to the front-end login page if no user is logged in.
     */
    public function getLoggedInUserOrRedirectToLogin (): ?Person {
//        try {
            $person = $this->getLoggedInUser(true);

        
//        }
//        } catch (ApiErrorCode $e) {
////            work from here.
////            die ('usernot found!');
//        }

        if (empty($person)) {
//            throw new ApiErrorCode(
//                ApiErrorCode::LOGIN_REQU IRED,
//                null,
//                BaseFrontendUrl::LOGIN
//            );

//            throw new UserNotLoggedInException();
        }
        // todo: add the destination the user originally wanted to their session.

        return $person;
    }

    /**
     * Remove any flashes that were added.
     * Used in testing as flash messages from verification and registration will stack up and be collected all together.
     */
    public function clearFlashes()
    {
        $msgs = $this->flashBag->get( 'success_msgs');
        $msgs = $this->flashBag->get( 'error_msgs');
    }
}